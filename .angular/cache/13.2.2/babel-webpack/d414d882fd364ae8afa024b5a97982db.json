{"ast":null,"code":"import { isPlatformBrowser as isPlatformBrowser$1, CommonModule } from '@angular/common';\nimport { Injectable, NgZone, defineInjectable, inject, EventEmitter, Directive, Inject, PLATFORM_ID, ElementRef, Input, Output, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { filter, takeUntil } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/*******************************************************************************\n * @license\n * Copyright (c) 2020 Piotr Stępniewski <k3nsei.pl@gmail.com>\n * (https://www.linkedin.com/in/piotrstepniewski/)\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://opensource.org/licenses/MIT\n */\n\n/** @enum {string} */\n\nimport * as ɵngcc0 from '@angular/core';\nconst InViewportConfigDirection = {\n  BOTH: 'both',\n  VERTICAL: 'vertical',\n  HORIZONTAL: 'horizontal'\n};\n/**\n * @return {?}\n */\n\nfunction isPlatformBrowser() {\n  try {\n    return typeof window !== 'undefined' && this === window;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * @param {?} input\n * @return {?}\n */\n\n\nfunction toBase64(input) {\n  return !isPlatformBrowser() ? toBase64Node(input) : toBase64Browser(input);\n}\n/**\n * @param {?} input\n * @return {?}\n */\n\n\nfunction toBase64Node(input) {\n  try {\n    return typeof global !== 'undefined' && global.Buffer.from(input).toString('base64');\n  } catch (e) {\n    return input;\n  }\n}\n/**\n * @param {?} input\n * @return {?}\n */\n\n\nfunction toBase64Browser(input) {\n  try {\n    return typeof window !== 'undefined' && window.btoa(input);\n  } catch (e) {\n    return input;\n  }\n}\n\nlet InViewportConfig = /*#__PURE__*/(() => {\n  class InViewportConfig {\n    /**\n     * @param {?=} options\n     */\n    constructor(options) {\n      this._rootMargin = '0px 0px 0px 0px';\n      this._threshold = [...InViewportConfig.DEFAULT_THRESHOLD];\n      this._partial = true;\n      this._direction = InViewportConfigDirection.BOTH;\n\n      if (Object.prototype.toString.call(options) === '[object Object]') {\n        ['root', 'rootMargin', 'threshold', 'partial', 'direction', 'checkFn'].forEach(prop => {\n          if (options.hasOwnProperty(prop)) {\n            this[prop] = options[prop];\n          }\n        });\n      }\n\n      this._hash = InViewportConfig.hash({\n        rootMargin: this.rootMargin,\n        threshold: this.threshold,\n        partial: this.partial,\n        direction: this.direction,\n        checkFn: String(this.checkFn)\n      });\n    }\n    /**\n     * @private\n     * @param {?} input\n     * @return {?}\n     */\n\n\n    static stringify(input) {\n      if (Array.isArray(input)) {\n        /** @type {?} */\n        const stringifiedArr = []; // tslint:disable-next-line:prefer-for-of\n\n        for (let i = 0; i < input.length; i++) {\n          stringifiedArr.push(InViewportConfig.stringify(input[i]));\n        }\n\n        return `[${stringifiedArr.join(',')}]`;\n      } else if (typeof input === 'object' && input !== null) {\n        /** @type {?} */\n        const acc = [];\n        /** @type {?} */\n\n        const sortedKeys = Object.keys(input).sort();\n\n        for (const k of sortedKeys) {\n          /** @type {?} */\n          const v = InViewportConfig.stringify(input[k]);\n          acc.push(`${k}:${v}`);\n        }\n\n        return acc.join(InViewportConfig.STRINGIFY_DELIMITER);\n      }\n\n      return String(input);\n    }\n    /**\n     * @private\n     * @param {?} input\n     * @return {?}\n     */\n\n\n    static hash(input) {\n      return toBase64(InViewportConfig.stringify(input));\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get root() {\n      return this._root;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set root(value) {\n      this._root = value && value.nodeType === 1 ? value : undefined;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get rootMargin() {\n      return this._rootMargin;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set rootMargin(value) {\n      if (!value || typeof value !== 'string') {\n        this._rootMargin = '0px 0px 0px 0px';\n      } else {\n        /** @type {?} */\n        const marginString = value || '0px';\n        /** @type {?} */\n\n        const margins = marginString.split(new RegExp('\\\\s+')).map(margin => {\n          /** @type {?} */\n          const parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\n\n          if (!parts) {\n            throw new TypeError('rootMargin must be specified in pixels or percent');\n          }\n\n          return `${parts[1]}${parts[2]}`;\n        });\n        margins[1] = margins[1] || margins[0];\n        margins[2] = margins[2] || margins[0];\n        margins[3] = margins[3] || margins[1];\n        this._rootMargin = margins.join(' ');\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get threshold() {\n      return this._threshold;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set threshold(value) {\n      /** @type {?} */\n      let threshold = [];\n      /** @type {?} */\n\n      const isValidThreshold = val => typeof val === 'number' && val >= 0 && val <= 1;\n\n      if (isValidThreshold(value)) {\n        threshold = [value];\n      } else if (Array.isArray(value) && value.length) {\n        threshold = value.filter(val => isValidThreshold(val));\n      }\n\n      if (threshold.length === 0) {\n        threshold = [...InViewportConfig.DEFAULT_THRESHOLD];\n      }\n\n      this._threshold = threshold;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get partial() {\n      return this._partial;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set partial(value) {\n      this._partial = !!value;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get direction() {\n      return this._direction;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set direction(value) {\n      /** @type {?} */\n      const isValidValue = val => {\n        return [InViewportConfigDirection.BOTH, InViewportConfigDirection.HORIZONTAL, InViewportConfigDirection.VERTICAL].indexOf(val) >= 0;\n      };\n\n      this._direction = isValidValue(value) ? value : InViewportConfigDirection.BOTH;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get hash() {\n      return this._hash;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    get checkFn() {\n      return this._checkFn;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set checkFn(value) {\n      this._checkFn = value;\n    }\n\n  }\n\n  InViewportConfig.DEFAULT_THRESHOLD = [0, 1];\n  InViewportConfig.STRINGIFY_DELIMITER = '|';\n  /**\n   * @fileoverview added by tsickle\n   * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n   */\n\n  return InViewportConfig;\n})();\n\nclass InViewportService {\n  /**\n   * @param {?} ngZone\n   */\n  constructor(ngZone) {\n    this.ngZone = ngZone;\n    this.trigger$ = new Subject();\n    this.registry = [];\n  }\n  /**\n   * @private\n   * @param {?} entries\n   * @return {?}\n   */\n\n\n  emitTrigger(entries) {\n    if (Array.isArray(entries) && entries.length) {\n      entries.forEach(entry => this.trigger$.next(entry));\n    }\n  }\n  /**\n   * @private\n   * @param {?=} element\n   * @return {?}\n   */\n\n\n  getRootElement(element) {\n    return element && element.nodeType === Node.ELEMENT_NODE ? element : null;\n  }\n  /**\n   * @private\n   * @param {?} root\n   * @param {?} configHash\n   * @return {?}\n   */\n\n\n  findEntry(root, configHash) {\n    return this.registry.find(entry => entry.root === this.getRootElement(root) && entry.configHash === configHash);\n  }\n  /**\n   * @param {?} target\n   * @param {?} config\n   * @return {?}\n   */\n\n\n  register(target, config) {\n    this.ngZone.runOutsideAngular(() => {\n      /** @type {?} */\n      const foundedEntry = this.findEntry(config.root, config.hash);\n\n      if (foundedEntry && !foundedEntry.targets.has(target)) {\n        foundedEntry.targets.add(target);\n        foundedEntry.observer.observe(target);\n      } else {\n        /** @type {?} */\n        const root = this.getRootElement(config.root);\n        /** @type {?} */\n\n        const options = {\n          root: root !== null ? root : undefined,\n          rootMargin: config.rootMargin,\n          threshold: config.threshold\n        };\n        /** @type {?} */\n\n        const entry = {\n          root,\n          configHash: config.hash,\n          targets: new Set([target]),\n          observer: new IntersectionObserver(entries => this.ngZone.run(() => this.emitTrigger(entries)), options)\n        };\n        entry.observer.observe(target);\n        this.registry = [...this.registry, entry];\n      }\n    });\n  }\n  /**\n   * @param {?} target\n   * @param {?} config\n   * @return {?}\n   */\n\n\n  unregister(target, config) {\n    this.ngZone.runOutsideAngular(() => {\n      /** @type {?} */\n      const foundedEntry = this.findEntry(config.root, config.hash);\n\n      if (foundedEntry) {\n        const {\n          observer,\n          targets\n        } = foundedEntry;\n\n        if (targets.has(target)) {\n          observer.unobserve(target);\n          targets.delete(target);\n        }\n\n        if (targets.size === 0) {\n          observer.disconnect();\n          this.registry = this.registry.filter(entry => entry !== foundedEntry);\n        }\n      }\n    });\n  }\n\n}\n\nInViewportService.ɵfac = function InViewportService_Factory(t) {\n  return new (t || InViewportService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone));\n};\n\nInViewportService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: InViewportService,\n  factory: InViewportService.ɵfac,\n  providedIn: 'root'\n});\n\n/** @nocollapse */\nInViewportService.ngInjectableDef = defineInjectable({\n  factory: function InViewportService_Factory() {\n    return new InViewportService(inject(NgZone));\n  },\n  token: InViewportService,\n  providedIn: \"root\"\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nconst InViewportMetadata = Symbol('InViewportMetadata');\nlet InViewportDirective = /*#__PURE__*/(() => {\n  class InViewportDirective {\n    /**\n     * @param {?} platformId\n     * @param {?} elementRef\n     * @param {?} inViewport\n     */\n    constructor(platformId, // tslint:disable-line\n    elementRef, inViewport) {\n      this.platformId = platformId;\n      this.elementRef = elementRef;\n      this.inViewport = inViewport;\n      this.config = new InViewportConfig();\n      this.destroyed$ = new Subject();\n      this.inViewportAction = new EventEmitter();\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n\n\n    set options(value) {\n      this.config = new InViewportConfig(value);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngAfterViewInit() {\n      if (isPlatformBrowser$1(this.platformId)) {\n        this.inViewport.register(this.elementRef.nativeElement, this.config);\n        this.inViewport.trigger$.pipe(filter(entry => {\n          return entry && entry.target === this.elementRef.nativeElement;\n        }), takeUntil(this.destroyed$)).subscribe(entry => {\n          this.emitAction(entry, false);\n        });\n      } else {\n        this.emitAction(undefined, true);\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      this.destroyed$.next();\n      this.destroyed$.complete();\n\n      if (isPlatformBrowser$1(this.platformId)) {\n        this.inViewport.unregister(this.elementRef.nativeElement, this.config);\n      }\n    }\n    /**\n     * @private\n     * @param {?} entry\n     * @param {?} force\n     * @return {?}\n     */\n\n\n    check(entry, force) {\n      /** @type {?} */\n      const isVisible = () => {\n        /** @type {?} */\n        const partiallyVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n        /** @type {?} */\n\n        const completelyVisible = entry.intersectionRatio >= 1;\n        return this.config.partial ? partiallyVisible : completelyVisible;\n      };\n      /** @type {?} */\n\n\n      const visible = force || !entry || isVisible();\n      return {\n        [InViewportMetadata]: {\n          entry\n        },\n        target: this.elementRef.nativeElement,\n        visible\n      };\n    }\n    /**\n     * @private\n     * @param {?} entry\n     * @param {?} force\n     * @return {?}\n     */\n\n\n    emitAction(entry, force) {\n      /** @type {?} */\n      const event = this.config.checkFn ? this.config.checkFn(entry, {\n        force,\n        config: this.config\n      }) : this.check(entry, force);\n      this.inViewportAction.emit(event);\n    }\n\n  }\n\n  InViewportDirective.ɵfac = function InViewportDirective_Factory(t) {\n    return new (t || InViewportDirective)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(InViewportService));\n  };\n\n  InViewportDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: InViewportDirective,\n    selectors: [[\"\", \"inViewport\", \"\"]],\n    inputs: {\n      options: [\"inViewportOptions\", \"options\"]\n    },\n    outputs: {\n      inViewportAction: \"inViewportAction\"\n    }\n  });\n  return InViewportDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet InViewportModule = /*#__PURE__*/(() => {\n  class InViewportModule {}\n\n  InViewportModule.ɵfac = function InViewportModule_Factory(t) {\n    return new (t || InViewportModule)();\n  };\n\n  InViewportModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: InViewportModule\n  });\n  InViewportModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return InViewportModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(InViewportModule, {\n    declarations: function () {\n      return [InViewportDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [InViewportDirective];\n    }\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { InViewportConfig, InViewportConfigDirection, InViewportDirective, InViewportMetadata, InViewportModule, InViewportService, isPlatformBrowser, toBase64, toBase64Browser, toBase64Node }; //# sourceMappingURL=ng-in-viewport.js.map","map":null,"metadata":{},"sourceType":"module"}