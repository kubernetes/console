{"ast":null,"code":"// Copyright 2017 The Kubernetes Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { SupportedResources } from '@api/root.shared';\nimport { isObject } from 'lodash';\nexport class PersistentVolumeSource {\n  constructor(volume) {\n    Object.assign(this, volume);\n  }\n\n  get source() {\n    const sourceKey = Object.keys(this).filter(key => {\n      const value = this[key];\n      return isObject(value) && value;\n    }).pop();\n\n    if (!sourceKey) {\n      return undefined;\n    }\n\n    const volumeSource = VolumeSourceRegistry.get(sourceKey);\n    return Object.assign(volumeSource, this[sourceKey]);\n  }\n\n} // Our custom object to extend Persistent Volume Sources with generic type/name information\n\nexport class IVolumeSource {}\nexport class HostPathVolumeSource {\n  get mountType() {\n    return 'HostPath';\n  }\n\n  get displayName() {\n    return this.path;\n  }\n\n}\nexport class EmptyDirVolumeSource {\n  get mountType() {\n    return 'EmptyDir';\n  }\n\n  get displayName() {\n    return '-';\n  }\n\n}\nexport class GCEPersistentDiskVolumeSource {\n  get mountType() {\n    return 'GCE Persistent Disk';\n  }\n\n  get displayName() {\n    return this.pdName;\n  }\n\n}\nexport class AWSElasticBlockStorageVolumeSource {\n  get mountType() {\n    return 'AWS Elastic Block Store';\n  }\n\n  get displayName() {\n    return this.volumeID;\n  }\n\n}\nexport class GitRepoVolumeSource {\n  get mountType() {\n    return 'GitRepo';\n  }\n\n  get displayName() {\n    return `${this.repository}/${this.directory}:${this.revision}`;\n  }\n\n}\nexport class SecretVolumeSource {\n  get mountType() {\n    return SupportedResources.Secret;\n  }\n\n  get displayName() {\n    return this.secretName;\n  }\n\n}\nexport class NFSVolumeSource {\n  get mountType() {\n    return 'NFS';\n  }\n\n  get displayName() {\n    return `${this.server}:${this.path}`;\n  }\n\n}\nexport class ISCSIVolumeSource {\n  get mountType() {\n    return 'ISCI';\n  }\n\n  get displayName() {\n    return `${this.targetPortal}/${this.iqn}/${this.lun}`;\n  }\n\n}\nexport class GlusterfsVolumeSource {\n  get mountType() {\n    return 'GlusterFS';\n  }\n\n  get displayName() {\n    return `${this.endpoints}/${this.path}`;\n  }\n\n}\nexport class PersistentVolumeClaimVolumeSource {\n  get mountType() {\n    return SupportedResources.PersistentVolumeClaim;\n  }\n\n  get displayName() {\n    return this.claimName;\n  }\n\n}\nexport class RBDVolumeSource {\n  get mountType() {\n    return 'RBD';\n  }\n\n  get displayName() {\n    return this.image;\n  }\n\n}\nexport class FlexVolumeSource {\n  get mountType() {\n    return 'Flex';\n  }\n\n  get displayName() {\n    return this.driver;\n  }\n\n}\nexport class CinderVolumeSource {\n  get mountType() {\n    return 'Cinder';\n  }\n\n  get displayName() {\n    return this.volumeID;\n  }\n\n}\nexport class CephFSVolumeSource {\n  get mountType() {\n    return 'CephFS';\n  }\n\n  get displayName() {\n    return this.path;\n  }\n\n}\nexport class FlockerVolumeSource {\n  get mountType() {\n    return 'Flocker';\n  }\n\n  get displayName() {\n    return this.datasetName;\n  }\n\n}\nexport class DownwardAPIVolumeSource {\n  get mountType() {\n    return 'DownwardAPI';\n  }\n\n  get displayName() {\n    return '-';\n  }\n\n}\nexport class FCVolumeSource {\n  get mountType() {\n    return 'FC';\n  }\n\n  get displayName() {\n    return '-';\n  }\n\n}\nexport class AzureFileVolumeSource {\n  get mountType() {\n    return 'Azure File';\n  }\n\n  get displayName() {\n    return this.shareName;\n  }\n\n}\nexport class ConfigMapVolumeSource {\n  get mountType() {\n    return SupportedResources.ConfigMap;\n  }\n\n  get displayName() {\n    return this.name;\n  }\n\n}\nexport class VSphereVirtualDiskVolumeSource {\n  get mountType() {\n    return 'VSphere Virtual Disk';\n  }\n\n  get displayName() {\n    return this.volumePath;\n  }\n\n}\nexport class QuobyteVolumeSource {\n  get mountType() {\n    return 'Quobyte';\n  }\n\n  get displayName() {\n    return this.volume;\n  }\n\n}\nexport class CSIVolumeSource {\n  get mountType() {\n    return 'CSI';\n  }\n\n  get displayName() {\n    return `${this.driver}/${this.volumeHandle}`;\n  }\n\n}\nexport class StorageOSVolumeSource {\n  get mountType() {\n    return 'Storage OS';\n  }\n\n  get displayName() {\n    return this.volumeName;\n  }\n\n}\nexport class ScaleIOVolumeSource {\n  get mountType() {\n    return 'Scale IO';\n  }\n\n  get displayName() {\n    return this.volumeName;\n  }\n\n}\nexport class PortworxVolumeSource {\n  get mountType() {\n    return 'Portworx';\n  }\n\n  get displayName() {\n    return this.volumeID;\n  }\n\n}\nexport class ProjectedVolumeSource {\n  get mountType() {\n    return 'Projected';\n  }\n\n  get displayName() {\n    return '-';\n  }\n\n}\nexport class PhotonPersistentDiskVolumeSource {\n  get mountType() {\n    return 'Photon Persistent Disk';\n  }\n\n  get displayName() {\n    return this.fsType;\n  }\n\n}\nexport class AzureDiskVolumeSource {\n  get mountType() {\n    return 'Azure Disk';\n  }\n\n  get displayName() {\n    return this.diskName;\n  }\n\n}\nexport class ServiceAccountTokenProjection {}\nexport class ConfigMapProjection {}\nexport class SecretProjection {}\nexport class DownwardAPIProjection {}\nexport class DownwardAPIVolumeFile {}\nexport class ResourceFieldSelector {}\nexport class ObjectFieldSelector {}\nexport class AzureDataDiskKind {}\nexport class AzureDataDiskCachingMode {}\nexport class KeyToPath {}\nexport class LocalObjectReference {} // Helper logic to allow better handling of volume source data and more generic access\n\nconst VolumeSourceRegistry = new Map([['hostPath', new HostPathVolumeSource()], ['emptyDir', new EmptyDirVolumeSource()], ['gcePersistentDisk', new GCEPersistentDiskVolumeSource()], ['awsElasticBlockStore', new AWSElasticBlockStorageVolumeSource()], ['gitRepo', new GitRepoVolumeSource()], ['secret', new SecretVolumeSource()], ['nfs', new NFSVolumeSource()], ['iscsi', new ISCSIVolumeSource()], ['glusterfs', new GlusterfsVolumeSource()], ['persistentVolumeClaim', new PersistentVolumeClaimVolumeSource()], ['rbd', new RBDVolumeSource()], ['flexVolume', new FlexVolumeSource()], ['cinder', new CinderVolumeSource()], ['cephfs', new CephFSVolumeSource()], ['flocker', new FlockerVolumeSource()], ['downwardAPI', new DownwardAPIVolumeSource()], ['fc', new FCVolumeSource()], ['azureFile', new AzureFileVolumeSource()], ['configMap', new ConfigMapVolumeSource()], ['vsphereVolume', new VSphereVirtualDiskVolumeSource()], ['quobyte', new QuobyteVolumeSource()], ['azureDisk', new AzureDiskVolumeSource()], ['photonPersistentDisk', new PhotonPersistentDiskVolumeSource()], ['projected', new ProjectedVolumeSource()], ['portworxVolume', new PortworxVolumeSource()], ['scaleIO', new ScaleIOVolumeSource()], ['storageOS', new StorageOSVolumeSource()], ['csi', new CSIVolumeSource()]]);","map":null,"metadata":{},"sourceType":"module"}