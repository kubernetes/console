{"ast":null,"code":"// Copyright 2017 The Kubernetes Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nimport { SimpleChanges } from '@angular/core';\nimport * as d3 from 'd3';\nimport { FormattedValue } from './helper';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/flex-layout/flex\";\nimport * as i2 from \"@angular/common\";\nimport * as i3 from \"@swimlane/ngx-charts\";\nimport * as i4 from \"ng-in-viewport\";\n\nfunction GraphComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 2);\n    i0.ɵɵelementStart(1, \"div\", 3);\n    i0.ɵɵi18n(2, 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction GraphComponent_ng_container_2_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"pre\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const model_r5 = ctx.model;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate2(\"\", model_r5[0].series, \": \", ctx_r4.getTooltipValue(model_r5[0].value), \"\");\n  }\n}\n\nconst _c2 = function () {\n  return {\n    partial: false\n  };\n};\n\nfunction GraphComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"ngx-charts-area-chart\", 5);\n    i0.ɵɵlistener(\"inViewportAction\", function GraphComponent_ng_container_2_Template_ngx_charts_area_chart_inViewportAction_1_listener($event) {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return ctx_r6.changeState($event);\n    });\n    i0.ɵɵtemplate(2, GraphComponent_ng_container_2_ng_template_2_Template, 2, 2, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"inViewportOptions\", i0.ɵɵpureFunction0(12, _c2))(\"xAxis\", true)(\"yAxis\", true)(\"showYAxisLabel\", true)(\"yAxisLabel\", ctx_r2.yAxisLabel)(\"yAxisTickFormatting\", ctx_r2.yAxisTickFormatting)(\"yScaleMax\", ctx_r2.yScaleMax)(\"results\", ctx_r2.series)(\"showGridLines\", true)(\"curve\", ctx_r2.curve)(\"customColors\", ctx_r2.customColors)(\"gradient\", true);\n  }\n}\n\nexport var GraphType = /*#__PURE__*/(() => {\n  (function (GraphType) {\n    GraphType[\"CPU\"] = \"cpu\";\n    GraphType[\"Memory\"] = \"memory\";\n  })(GraphType || (GraphType = {}));\n\n  return GraphType;\n})();\n\nvar TimeScale = /*#__PURE__*/(() => {\n  (function (TimeScale) {\n    TimeScale[TimeScale[\"Minutes\"] = 0] = \"Minutes\";\n    TimeScale[TimeScale[\"Hours\"] = 1] = \"Hours\";\n    TimeScale[TimeScale[\"Days\"] = 2] = \"Days\";\n  })(TimeScale || (TimeScale = {}));\n\n  return TimeScale;\n})();\n\nexport let GraphComponent = /*#__PURE__*/(() => {\n  class GraphComponent {\n    constructor() {\n      this.graphType = GraphType.CPU;\n      this.series = [];\n      this.curve = d3.curveMonotoneX;\n      this.customColors = {};\n      this.yAxisLabel = '';\n      this.yScaleMax = 0;\n      this.shouldShowGraph = false;\n      this.suffixMap_ = new Map();\n      this.yAxisSuffix_ = '';\n      this.visible_ = false;\n      this.minMetricsCount_ = 5;\n      this.maxMetricsCount_ = 15;\n      this.timeScale_ = TimeScale.Minutes;\n\n      this.yAxisTickFormatting = value => `${value} ${this.yAxisSuffix_}`;\n    }\n\n    ngOnInit() {\n      if (!this.graphType) {\n        throw new Error('Graph type has to be provided.');\n      }\n\n      this.series = this._generateSeries();\n      this.customColors = this._getColor();\n      this.yAxisLabel = this.graphType === GraphType.CPU ? 'CPU (cores)' : 'Memory (bytes)';\n    }\n\n    ngOnChanges(_) {\n      if (this.visible_) {\n        this.suffixMap_.clear();\n        this.series = this._generateSeries();\n      }\n    }\n\n    changeState(isInViewPort) {\n      this.visible_ = isInViewPort.visible;\n    }\n\n    getTooltipValue(value) {\n      return `${value} ${this.suffixMap_.has(value) ? this.suffixMap_.get(value) : ''}`;\n    }\n\n    _generateSeries() {\n      let points = [];\n      let series;\n      let highestSuffixPower = 0;\n      let highestSuffix = '';\n      let maxValue = 0;\n\n      switch (this.graphType) {\n        case GraphType.Memory:\n          series = this.metric.dataPoints.map(point => FormattedValue.NewFormattedMemoryValue(point.y));\n          break;\n\n        case GraphType.CPU:\n          series = this.metric.dataPoints.map(point => FormattedValue.NewFormattedCoreValue(point.y));\n          break;\n\n        default:\n          throw new Error(`Unsupported graph type ${this.graphType}.`);\n      } // Find out the highest suffix and normalize all values to a single suffix\n\n\n      series.map(value => {\n        if (highestSuffixPower < value.suffixPower) {\n          highestSuffixPower = value.suffixPower;\n          highestSuffix = value.suffix;\n        }\n\n        value.normalize(highestSuffix);\n        return value;\n      });\n      this.yAxisSuffix_ = highestSuffix;\n      this.metric.dataPoints.forEach((_, idx) => {\n        points.push({\n          x: this.metric.dataPoints[idx].x,\n          y: series[idx].value\n        });\n      });\n\n      this._findTimeScale(points);\n\n      points = points.reduce(this._average.bind(this), []);\n      this.shouldShowGraph = points.length >= this.minMetricsCount_;\n      points = this._averageWithReduce(points, this.maxMetricsCount_);\n      const result = [{\n        name: this.id,\n        series: points.map(point => {\n          if (maxValue < point.y) {\n            maxValue = point.y;\n          }\n\n          return {\n            value: Number(point.y.toPrecision(3)),\n            name: d3.timeFormat('%H:%M')(new Date(1000 * point.x))\n          };\n        })\n      }]; // This way if max value is very small i.e. 0.0001 graph will be scaled to the more significant\n      // value.\n\n      switch (this.graphType) {\n        case GraphType.CPU:\n          this.yScaleMax = maxValue + 0.01;\n          break;\n\n        case GraphType.Memory:\n          this.yScaleMax = maxValue + 10;\n          break;\n\n        default:\n      }\n\n      return result;\n    } // Calculate the average usage based on detected time unit intervals. If there are more data points than\n    // max allowed metrics, they will be accumulated and an average will be taken.\n\n\n    _average(acc, point, idx, points) {\n      if (idx > 0) {\n        const currTimeUnit = this._getTimeScale(point.x);\n\n        const lastTimeUnit = this._getTimeScale(points[idx - 1].x); // Time unit changed or we are at the end of an array\n\n\n        if (currTimeUnit !== lastTimeUnit || idx === points.length - 1) {\n          let i = idx - 2; // Initialize with last time unit\n\n          const minutes = [points[idx - 1].y]; // Track back all remaining points for the last time unit\n\n          while (i >= 0 && lastTimeUnit === this._getTimeScale(points[i].x)) {\n            minutes.push(points[i].y);\n            i--;\n          } // Calculate an average of this time unit values\n\n\n          const average = minutes.reduce((a, b) => a + b, 0) / minutes.length; // Accumulate the result\n\n          return acc.concat({\n            x: points[idx - 1].x,\n            y: average\n          });\n        }\n      }\n\n      return acc;\n    } // Average with reduce scales the number of provided points to the given limit.\n\n\n    _averageWithReduce(points, limit) {\n      const result = [];\n      const divider = Math.floor(points.length / limit);\n      let reminder = points.length % limit;\n\n      if (divider === 0 || divider === 1 && reminder === 0) {\n        return points;\n      }\n\n      for (let i = 0; i < points.length; i += divider) {\n        let sum = 0;\n        let count = 0;\n\n        for (let j = 0; j < divider && i + j < points.length; j++) {\n          sum += points[i + j].y;\n          count++;\n        }\n\n        if (reminder > 0) {\n          sum += points[i + divider].y;\n          i++;\n          count++;\n          reminder--;\n        }\n\n        result.push({\n          x: points[i].x,\n          y: sum / count\n        });\n      }\n\n      return result;\n    }\n\n    _getTimeScale(date) {\n      switch (this.timeScale_) {\n        case TimeScale.Minutes:\n          return this._getMinute(date);\n\n        case TimeScale.Hours:\n          return this._getHour(date);\n\n        case TimeScale.Days:\n          return this._getDay(date);\n      }\n    }\n\n    _getMinute(date) {\n      return new Date(1000 * date).getMinutes();\n    }\n\n    _getHour(date) {\n      return new Date(1000 * date).getHours();\n    }\n\n    _getDay(date) {\n      return new Date(1000 * date).getDay();\n    }\n\n    _findTimeScale(points) {\n      if (points.length < 1) {\n        return;\n      }\n\n      let metricsCount = 1;\n\n      let lastTimeUnit = this._getTimeScale(points.pop().x);\n\n      points.forEach(point => {\n        const currTimeUnit = this._getTimeScale(point.x);\n\n        if (lastTimeUnit !== currTimeUnit) {\n          lastTimeUnit = currTimeUnit;\n          metricsCount++;\n        }\n      });\n\n      if (metricsCount <= this.minMetricsCount_ && this.timeScale_ > TimeScale.Minutes) {\n        this.timeScale_--;\n        return;\n      }\n\n      if (metricsCount > this.maxMetricsCount_ && this.timeScale_ < TimeScale.Days) {\n        this.timeScale_++;\n\n        this._findTimeScale(points);\n      }\n    }\n\n    _getColor() {\n      return this.graphType === GraphType.CPU ? [{\n        name: this.id,\n        value: '#00c752'\n      }] : [{\n        name: this.id,\n        value: '#326de6'\n      }];\n    }\n\n  }\n\n  GraphComponent.ɵfac = function GraphComponent_Factory(t) {\n    return new (t || GraphComponent)();\n  };\n\n  GraphComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: GraphComponent,\n    selectors: [[\"kd-graph\"]],\n    inputs: {\n      metric: \"metric\",\n      id: \"id\",\n      graphType: \"graphType\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 3,\n    vars: 2,\n    consts: function () {\n      let i18n_0;\n\n      if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n        const MSG_EXTERNAL_7226453598592665781$$SRC_APP_FRONTEND_COMMON_COMPONENTS_GRAPH_COMPONENT_TS__1 = goog.getMsg(\" Waiting for more data to display chart... \");\n        i18n_0 = MSG_EXTERNAL_7226453598592665781$$SRC_APP_FRONTEND_COMMON_COMPONENTS_GRAPH_COMPONENT_TS__1;\n      } else {\n        i18n_0 = $localize` Waiting for more data to display chart... `;\n      }\n\n      return [[\"noData\", \"\"], [4, \"ngIf\", \"ngIfElse\"], [\"fxLayout\", \"column\", 1, \"kd-muted\", \"chart-container\"], [\"fxFlexAlign\", \"center\", 1, \"empty-chart-text\"], i18n_0, [\"fxFlex\", \"\", \"inViewport\", \"\", 3, \"inViewportOptions\", \"xAxis\", \"yAxis\", \"showYAxisLabel\", \"yAxisLabel\", \"yAxisTickFormatting\", \"yScaleMax\", \"results\", \"showGridLines\", \"curve\", \"customColors\", \"gradient\", \"inViewportAction\"], [\"seriesTooltipTemplate\", \"\"]];\n    },\n    template: function GraphComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, GraphComponent_ng_template_0_Template, 3, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(2, GraphComponent_ng_container_2_Template, 4, 13, \"ng-container\", 1);\n      }\n\n      if (rf & 2) {\n        const _r0 = i0.ɵɵreference(1);\n\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.shouldShowGraph)(\"ngIfElse\", _r0);\n      }\n    },\n    directives: [i1.DefaultLayoutDirective, i1.DefaultFlexAlignDirective, i2.NgIf, i3.AreaChartComponent, i1.DefaultFlexDirective, i4.InViewportDirective],\n    styles: [\".chart-container[_ngcontent-%COMP%] {\\n  padding: 16px;\\n}\\n\\n.empty-chart-text[_ngcontent-%COMP%] {\\n  font-size: 24px;\\n  font-weight: 400;\\n  margin-bottom: 4px;\\n}\"]\n  });\n  return GraphComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}